/**
 * @param timezone - IANA timezone string (e.g., "America/New_York")
 */
export function timezoneToLocation(timezone: string): string {
  if (!timezone) return '';

  // Essential timezone to location mappings
  // Only include cases where fallback logic would produce incorrect/suboptimal results
  const timezoneLocationMap: Record<string, string> = {
    // Cases where timezone name differs significantly from common city name
    'Asia/Ho_Chi_Minh': 'Ho Chi Minh City',
    'Asia/Kolkata': 'Mumbai', // Most people know it as Mumbai
    'Asia/Qatar': 'Doha',
    'Asia/Kuwait': 'Kuwait City',
    'America/Mexico_City': 'Mexico City',
    'America/Sao_Paulo': 'São Paulo',
    'America/Buenos_Aires': 'Buenos Aires',
    'America/Bogota': 'Bogotá',
    'Europe/Kiev': 'Kyiv', // Current preferred spelling
    'Africa/Addis_Ababa': 'Addis Ababa',
    'Pacific/Fiji': 'Suva',

    // Cases with underscores that need special handling
    'Asia/Hong_Kong': 'Hong Kong',
    'Asia/Kuala_Lumpur': 'Kuala Lumpur',
    'Asia/Phnom_Penh': 'Phnom Penh',

    // Multi-word city names that fallback handles poorly
    'America/New_York': 'New York',
    'America/Los_Angeles': 'Los Angeles',
  };

  // Check if we have a predefined mapping
  if (timezoneLocationMap[timezone]) {
    return timezoneLocationMap[timezone];
  }

  // Fallback: extract city name from timezone string
  const parts = timezone.split('/');
  if (parts.length >= 2) {
    const cityPart = parts[parts.length - 1];

    // Enhanced fallback processing
    return cityPart
      .replace(/_/g, ' ') // Replace underscores with spaces
      .split(' ')
      .map((word) => {
        // Capitalize first letter of each word
        // Handle common abbreviations
        const lowerWord = word.toLowerCase();
        if (lowerWord === 'city') return 'City';
        if (lowerWord === 'st') return 'St.';
        if (lowerWord === 'san') return 'San';
        if (lowerWord === 'new') return 'New';
        if (lowerWord === 'port') return 'Port';

        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      })
      .join(' ');
  }

  return timezone;
}

/**
 * Checks if the current location matches the timezone
 * Used to determine if we should auto-update the location
 */
export function shouldAutoUpdateLocation(
  currentLocation: string,
  newTimezone: string,
): boolean {
  if (!currentLocation || currentLocation.trim() === '') {
    return true; // Always update if location is empty
  }

  const suggestedLocation = timezoneToLocation(newTimezone);

  // Don't auto-update if user has manually entered a custom location
  // We check if current location is significantly different from what we would suggest
  const currentNormalized = currentLocation.toLowerCase().trim();
  const suggestedNormalized = suggestedLocation.toLowerCase().trim();

  // If they're very similar, it's likely our auto-generated name, so we can update
  if (currentNormalized === suggestedNormalized) {
    return true;
  }

  // Check if current location might be an auto-generated one from previous timezone
  // by seeing if it looks like a timezone-derived name (has proper capitalization, no special chars)
  const looksAutoGenerated = /^[A-Z][a-z]*(\s[A-Z][a-z]*)*$/.test(currentLocation.trim());

  return looksAutoGenerated;
}
